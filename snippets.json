{
	"Start": {
		"prefix": "cd",
		"body": [
			"#include <bits/stdc++.h>", 
			"#define GOOD_LUCK ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);",
			"#define int long long",
			"#define endl \"\\n\"",
			"#define ff first",
			"#define ss second",
			"#define pb push_back",
			"#define all(v) v.begin(), v.end()",
			"using namespace std;",
			"",
			"constexpr int MAX = 2e+5 + 1, INF = 2e+16, MOD = 1e+9 + 7, K = 31;",
			"",
			"void _() {",
			"\t$0",
			"}",
			"",
			"signed main() {",
			"",
			"\tGOOD_LUCK",
			"",
			"\tint tests=1;",
			"\tcin >> tests;",
			"\tfor (int i=1; i <= tests; i++) {",
			"\t\t_();",
			"\t\tcout << endl;",
			"\t}",
			"",
			"\treturn 0;",
			"}"
		],
		"description": "Started Code"
	},

	"Segment Tree": {
		"prefix": "call_seg",
		"body": [
			"struct SegTree{",
            "\tint n;",
            "\tvector <int> a, t;",
            "\tvoid init(int n1, vector <int> &v) {",
            "\t\tn = n1;",
            "\t\ta = v;",
            "\t\tt.resize(4*(n+2));",
            "\t}",
            "\tint merge(int a, int b) {",
            "\t\treturn min(a, b)$0;       // TODO",
            "\t}",
            "\tvoid build(int v, int tl, int tr) {",
            "\t\tif (tl == tr) {",
            "\t\t\tt[v] = a[tl];",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tint tm = (tl + tr) / 2;",
            "\t\tbuild(2*v, tl, tm);",
            "\t\tbuild(2*v+1, tm+1, tr);",
            "\t\tt[v] = merge(t[v*2], t[v*2+1]);",
            "\t}",
            "\tint find(int v, int tl, int tr, int l, int r) {",
            "\t\tif (l > r) return INF;      // TODO",
            "\t\tif (tl == l && tr == r) return t[v];",
            "\t\tint tm = (tl + tr) / 2;",
            "\t\tint r1 = find(v*2, tl, tm, l, min(r, tm));",
            "\t\tint r2 = find(v*2+1, tm+1, tr, max(l, tm+1), r);",
            "\t\treturn merge(r1, r2);",
            "\t}",
            "\tvoid update(int v, int tl, int tr, int i, int x) {",
            "\t\tif (tl == tr) {",
            "\t\t\tt[v] = x;",
            "\t\t\ta[tl] = x;",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tint tm = (tl + tr) / 2;",
            "\t\tif (i <= tm) update(v*2, tl, tm, i, x);",
            "\t\telse update(v*2+1, tm+1, tr, i, x);",
            "\t\tt[v] = merge(t[v*2], t[v*2+1]);",
            "\t}",
            "\tint get(int l, int r) {",
            "\t\treturn find(1, 0, n-1, l, r);",
            "\t}",
            "\tvoid upd(int i, int x) {",
            "\t\tupdate(1, 0, n-1, i, x);",
            "\t}",
            "};"
		],
		"description": "Segment Tree"
	},

    "FenwickTree": {
        "prefix": "call_bit",
        "body": [
            "struct BIT{",
            "\tint n;",
            "\tvector <int> t;",
            "\tvoid init(int n1) {",
            "\t\tn = n1;",
            "\t\tt.assign(n+1, 0);",
            "\t}",
            "\tint get(int l, int r) {",
            "\t\tif (l > r) return 0;",
            "\t\tif (l != 1) return get(1, r) - get(1, l-1);",
            "\t\tint res=0;",
            "\t\twhile (r >= 1) {",
            "\t\t\tres += t[r];",
            "\t\t\tr -= (r & (-r));",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "\tvoid upd(int i, int x) {",
            "\t\twhile (i <= n) {",
            "\t\t\tt[i] += x;",
            "\t\t\ti += (i & (-i));",
            "\t\t}",
            "\t}",
            "};"
        ],
        "description": "Fenwick Tree"
    },

    "Compress": {
        "prefix": "call_press",
        "body": [
            "int compress(vector <int> &v) {",
            "\tint n = v.size();",
            "\tvector <pair<int, int>> x;",
            "\tfor (int i=0; i < n; i++) x.pb({v[i], i});",
            "\tsort(all(x));",
            "\tint nxt=1;",
            "\tfor (int i=0; i < n-1; i++) {",
            "\t\tif (x[i].ff == x[i+1].ff) x[i].ff = nxt;",
            "\t\telse x[i].ff = nxt++;",
            "\t}",
            "\tx.back().ff = nxt;",
            "\tfor (auto &i : x) v[i.ss] = i.ff;",
            "\treturn nxt;",
            "}"        
        ],
        "description": "compress vector"
    },

    "DSU": {
        "prefix": "call_dsu",
        "body": [
            "struct DSU{",
            "\tint n;",
            "\tvector <int> par;",
            "\tvoid init(int n1) {",
            "\t\tn = n1;",
            "\t\tpar.assign(n+1, -1);",
            "\t}",
            "\tint get(int u) {",
            "\t\tif (par[u] < 0) return u;",
            "\t\treturn par[u] = get(par[u]);",
            "\t}",
            "\tbool un(int a, int b) {",
            "\t\ta = get(a);",
            "\t\tb = get(b);",
            "\t\tif(a == b) return 0;",
            "\t\tif (par[a] < par[b]) swap(a, b);",
            "\t\tpar[b] += par[a];",
            "\t\tpar[a] = b;",
            "\t\treturn 1;",
            "\t}",
            "};"
        ],
        "description": "DSU"
    },

    "DFS": {
        "prefix": "call_dfs",
        "body": [
            "void dfs(int u) {",
            "\tcol[u] = 1;",
            "\tfor (int &i : g[u]) {",
            "\t\tif (!col[i]) dfs(i);",
            "\t}",
            "}"
        ],
        "description": "DFS in graph"
    },

    "DFS in TREE": {
        "prefix": "call_dfst",
        "body": [
            "void dfs(int u, int c=-1) {",
            "\tfor (int &i : g[u]) {",
            "\t\tif (i == c) continue;",
            "\t\tdfs(i, u);",
            "\t}",
            "}"
        ],
        "description": "DFS in tree"
    },

    "BFS": {
        "prefix": "call_bfs",
        "body": [
            "void bfs(int s) {",
            "\tdis[s] = 0;",
            "\tqueue<int> q;",
            "\tq.push(s);",
            "\tcol[s] = 1;",
            "\twhile (!q.empty()) {",
            "\t\tint u = q.front();",
            "\t\tq.pop();",
            "\t\tfor (int &i : g[u]) {",
            "\t\t\tif (!col[i]) {",
            "\t\t\t\tdis[i] = dis[u] + 1;",
            "\t\t\t\tcol[i] = 1;",
            "\t\t\t\tq.push(i);",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "}"
        ],
        "description": "BFS in graph"
    },

    "DIJKSTRA": {
        "prefix": "call_dijkstra",
        "body": [
            "void dijkstra(int s) {",
            "\tdis[s] = 0;",
            "\tpriority_queue<pair<int, int>, vector <pair<int, int>>, greater<pair<int, int>>> q;",
            "\tq.push({0, s});",
            "\twhile (!q.empty()) {",
            "\t\tint d = q.top().ff, u = q.top().ss;",
            "\t\tq.pop();",
            "\t\tif (d > dis[u]) continue;",
            "\t\tfor (auto &i : g[u]) {",
            "\t\t\tint to = i.ff, c = i.ss;",
            "\t\t\tif (dis[to] > dis[u] + c) {",
            "\t\t\t\tdis[to] = dis[u] + c;",
            "\t\t\t\tpar[to] = u;",
            "\t\t\t\tq.push({dis[to], to});",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "}"
        ],
        "description": "Dijkstra in graph"
    },

    "MO_SORT": {
        "prefix": "call_mo",
        "body": [
            "\tsort(all(que), [&](auto &x1, auto &x2){",
            "\t\tif (x1[0] / B == x2[0] / B) {",
            "\t\t\tif ((x1[0] / B) % 2) return x1[1] < x2[1];",
            "\t\t\treturn x1[1] > x2[1];",
            "\t\t}",
            "\t\treturn x1[0] < x2[0];",
            "\t});"
        ],
        "description": "Sort for MO"
    },
    
    "Implicit Segment Tree": {
        "prefix": "call_imp",
        "body": [
            "struct ImpTree {",
            "\tint n;",
            "\tvector <int> L, R, t;",
            "\tint nxt=1;",
            "\tvoid init(int n1) {",
            "\t\tn = n1;",
            "\t\tL.assign(MAX*4, -1), R.assign(MAX*4, -1), t.assign(MAX*4, -1);\t\t// TODO",
            "\t}",
            "\tint merge(int a, int b) {",
            "\t\treturn max(a, b);\t\t   // TODO",
            "\t}",
            "\tint find(int v, int tl, int tr, int l, int r) {",
            "\t\tif (l > r) return -1;\t   // TODO",
            "\t\tif (tl == l && tr == r) return t[v];",
            "\t\tint tm = (tl + tr) / 2;",
            "\t\tint r1=-1, r2=-1;",
            "\t\tif (L[v] != -1) r1 = find(L[v], tl, tm, l, min(r, tm));",
            "\t\tif (R[v] != -1) r2 = find(R[v], tm+1, tr, max(l, tm+1), r);",
            "\t\treturn merge(r1, r2);",
            "\t}",
            "\tvoid update(int v, int tl, int tr, int i, int x) {",
            "\t\tif (tl == tr) {",
            "\t\t\tt[v] = x;",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tint tm = (tl + tr) / 2;",
            "\t\tif (i <= tm) {",
            "\t\t\tif (L[v] == -1) L[v] = ++nxt;",
            "\t\t\tupdate(L[v], tl, tm, i, x);",
            "\t\t}",
            "\t\telse {",
            "\t\t\tif (R[v] == -1) R[v] = ++nxt;",
            "\t\t\tupdate(R[v], tm+1, tr, i, x);",
            "\t\t}",
            "\t\tt[v] = -1;",
            "\t\tif (L[v] != -1) t[v] = merge(t[v], t[L[v]]);",
            "\t\tif (R[v] != -1) t[v] = merge(t[v], t[L[v]]);",
            "\t}",
            "\tint get(int l, int r) {",
            "\t\treturn find(1, 0, n-1, l, r);\t\t//TODO",
            "\t}",
            "\tvoid upd(int i, int x) {",
            "\t\tupdate(1, 0, n-1, i, x);\t\t// TODO",
            "\t}",
            "};"
        ],
        "description": "Implicit Seg Tree"
    },
    "My sort": {
        "prefix": "call_mysort",
        "body": [
            "void mysort(vector <int> &v) {",
            "\tint n = v.size();",
            "\tvector <int> o = v;",
            "\tint ma=*max_element(all(v));",
            "\tint b = sqrt(ma * 2) + 10;",
            "\tvector <int> id;",
            "\tfor (int i = 0; i < n; i++) id.pb(i);",
            "\tfor (int i = 0; i < 2; i++) {",
            "\t\tvector <vector <int>> c(b);",
            "\t\tfor (int &j : id) {",
            "\t\t\tint x = v[j] % b;",
            "\t\t\tv[j] /= b;",
            "\t\t\tc[x].pb(j);",
            "\t\t}",
            "\t\tid.clear();",
            "\t\tfor (int j = 0; j < b; j++) {",
            "\t\t\tfor (int &z : c[j]) id.pb(z);",
            "\t\t}",
            "\t}",
            "\tfor (int i=0; i < n; i++) v[i] = o[id[i]];",
            "}"
        ],
        "description": "My sorting Algorithm"
    },
    
    "Wavelet Tree": {
        "prefix": "call_wavelet",
        "body": [
            "struct wavelet{",
            "\tint mn, mx, nxt=1;",
            "\tvector <vector <int>> t, pr;",
            "\tvector <int> L, R;",
            "\tvoid init(int mi, int ma) {",
            "\t\tmn = mi, mx = ma;",
            "\t\tt.pb({});",
            "\t\tpr.pb({});",
            "\t\tL.pb(-1);",
            "\t\tR.pb(-1);",
            "\t}",
            "\tvoid build(int v, int tl, int tr, vector <int> &a) {",
            "\t\tint tm = (tl + tr) / 2;",
            "\t\tif (v == 1) {",
            "\t\t\tt.pb({});",
            "\t\t\tfor (int i = 0; i < a.size(); i++) t[v].pb(a[i]);",
            "\t\t}",
            "\t\twhile (pr.size() <= v) pr.pb({});",
            "\t\tpr[v].pb(0);",
            "\t\tfor (int i = 0; i < t[v].size(); i++) {",
            "\t\t\tif (t[v][i] <= tm) pr[v].pb(1);",
            "\t\t\telse pr[v].pb(0);",
            "\t\t}",
            "\t\tfor (int i = 1; i < pr[v].size(); i++) pr[v][i] += pr[v][i-1];",
            "\t\tif (tl == tr) return;",
            "\t\twhile (L.size() <= v) L.pb(-1);",
            "\t\twhile (R.size() <= v) R.pb(-1);",
            "\t\tL[v] = ++nxt;",
            "\t\tR[v] = ++nxt;",
            "\t\twhile (t.size() <= R[v]) t.pb({});",
            "\t\tfor (int i = 0; i < t[v].size(); i++) {",
            "\t\t\tif (t[v][i] <= tm) t[L[v]].pb(t[v][i]);",
            "\t\t\telse t[R[v]].pb(t[v][i]);",
            "\t\t}",
            "\t\tif (t[L[v]].size()) build(L[v], tl, tm, a);",
            "\t\tif (t[R[v]].size()) build(R[v], tm+1, tr, a);",
            "\t}",
            "\tvoid bld(vector <int> &v) { build(1, mn, mx, v); }",
            "\tint findk(int v, int tl, int tr, int l, int r, int k) {",
            "\t\tif (tl == tr) return tl;",
            "\t\tint tm = (tl + tr) / 2;",
            "\t\tint ct = pr[v][r+1] - pr[v][l];",
            "\t\tif (ct >= k) return findk(L[v], tl, tm, pr[v][l], pr[v][r+1] - 1, k);",
            "\t\telse return findk(R[v], tm+1, tr, l - pr[v][l], r - pr[v][r+1], k - ct);",
            "\t}",
            "\tint kth(int l, int r, int k) { return findk(1, mn, mx, l, r, k); }",
            "\tint findsmallerk(int v, int tl, int tr, int l, int r, int k) {",
            "\t\tif (l > r) return 0;",
            "\t\tif (tl == tr) return r - l + 1;",
            "\t\tint tm = (tl + tr) / 2;",
            "\t\tif (k <= tm) {",
            "\t\t\treturn findsmallerk(L[v], tl, tm, pr[v][l], pr[v][r+1] - 1, k);",
            "\t\t}",
            "\t\telse {",
            "\t\t\treturn findsmallerk(R[v], tm+1, tr, l - pr[v][l], r - pr[v][r+1], k) + pr[v][r+1] - pr[v][l];",
            "\t\t}",
            "\t}",
            "\tint smallk(int l, int r, int k) { return findsmallerk(1, mn, mx, l, r, k); }",
            "\tint findbiggerk(int v, int tl, int tr, int l, int r, int k) {",
            "\t\tif (l > r) return 0;",
            "\t\tif (tl == tr) return r - l + 1;",
            "\t\tint tm = (tl + tr) / 2;",
            "\t\tif (k <= tm) {",
            "\t\t\treturn findbiggerk(L[v], tl, tm, pr[v][l], pr[v][r+1] - 1, k) + r - l + 1 - pr[v][r+1] + pr[v][l];",
            "\t\t}",
            "\t\telse {",
            "\t\t\treturn findbiggerk(R[v], tm+1, tr, l - pr[v][l], r - pr[v][r+1], k);",
            "\t\t}",
            "\t}",
            "\tint bigk(int l, int r, int k) { return findbiggerk(1, mn, mx, l, r, k); }",
            "};",
        ],
        "description": "Wavelet Tree Implementation"
    },

    "Pragmas": {
        "prefix": "call_pragmas",
        "body": [
            "#pragma GCC optimize(\"O3\")",
            "#pragma GCC optimize(\"Ofast\")",
            "#pragma GCC optimize(\"inline\")",
            "#pragma GCC optimize(\"-fgcse\")",
            "#pragma GCC optimize(\"-fgcse-lm\")",
            "#pragma GCC optimize(\"-fipa-sra\")",
            "#pragma GCC optimize(\"-ftree-pre\")",
            "#pragma GCC optimize(\"-ftree-vrp\")",
            "#pragma GCC optimize(\"-fpeephole2\")",
            "#pragma GCC optimize(\"-ffast-math\")",
            "#pragma GCC optimize(\"-fsched-spec\")",
            "#pragma GCC optimize(\"unroll-loops\")",
            "#pragma GCC optimize(\"-falign-jumps\")",
            "#pragma GCC optimize(\"-falign-loops\")",
            "#pragma GCC optimize(\"-falign-labels\")",
            "#pragma GCC optimize(\"-fdevirtualize\")",
            "#pragma GCC optimize(\"-fcaller-saves\")",
            "#pragma GCC optimize(\"-fcrossjumping\")",
            "#pragma GCC optimize(\"-fthread-jumps\")",
            "#pragma GCC optimize(\"-funroll-loops\")",
            "#pragma GCC optimize(\"-fwhole-program\")",
            "#pragma GCC optimize(\"-freorder-blocks\")",
            "#pragma GCC optimize(\"-fschedule-insns\")",
            "#pragma GCC optimize(\"inline-functions\")",
            "#pragma GCC optimize(\"-ftree-tail-merge\")",
            "#pragma GCC optimize(\"-fschedule-insns2\")",
            "#pragma GCC optimize(\"-fstrict-aliasing\")",
            "#pragma GCC optimize(\"-fstrict-overflow\")",
            "#pragma GCC optimize(\"-falign-functions\")",
            "#pragma GCC optimize(\"-fcse-skip-blocks\")",
            "#pragma GCC optimize(\"-fcse-follow-jumps\")",
            "#pragma GCC optimize(\"-fsched-interblock\")",
            "#pragma GCC optimize(\"-fpartial-inlining\")",
            "#pragma GCC optimize(\"no-stack-protector\")",
            "#pragma GCC optimize(\"-freorder-functions\")",
            "#pragma GCC optimize(\"-findirect-inlining\")",
            "#pragma GCC optimize(\"-fhoist-adjacent-loads\")",
            "#pragma GCC optimize(\"-frerun-cse-after-loop\")",
            "#pragma GCC optimize(\"inline-small-functions\")",
            "#pragma GCC optimize(\"-finline-small-functions\")",
            "#pragma GCC optimize(\"-ftree-switch-conversion\")",
            "#pragma GCC optimize(\"-foptimize-sibling-calls\")",
            "#pragma GCC optimize(\"-fexpensive-optimizations\")",
            "#pragma GCC optimize(\"-funsafe-loop-optimizations\")",
            "#pragma GCC optimize(\"inline-functions-called-once\")",
            "#pragma GCC optimize(\"-fdelete-null-pointer-checks\")",
        ],
        "description": "A lot of Pragma"
    },

    "Math Defines": {
        "prefix": "call_math",
        "body": [
            "#define M_E        2.71828182845904523536",
            "#define M_LOG2E    1.44269504088896340736",
            "#define M_LOG10E   0.434294481903251827651",
            "#define M_LN2      0.693147180559945309417",
            "#define M_LN10     2.30258509299404568402",
            "#define M_PI       3.14159265358979323846",
            "#define M_PI_2     1.57079632679489661923",
            "#define M_PI_4     0.785398163397448309616",
            "#define M_1_PI     0.318309886183790671538",
            "#define M_2_PI     0.636619772367581343076",
            "#define M_2_SQRTPI 1.12837916709551257390",
            "#define M_SQRT2    1.41421356237309504880",
            "#define M_SQRT1_2  0.707106781186547524401"
        ],
        "description": "Math defines"
    },
    
    "Combinatorics": {
        "prefix": "call_comb",
        "body": [
            "int exp(int a, int b, int c = MOD) {",
            "\tif (b == 0) return 1;",
            "\tif (b % 2) return (a * exp(a, b-1, c)) % c;",
            "\treturn exp((a*a)%c, b/2, c) % c;",
            "}",
            "",
            "int inv(int a, int b = MOD){",
            "\treturn exp(a, b-2);",
            "}",
            "",
            "int C(int n, int k, int c = MOD) {",
            "\tint res=f[n];",
            "\tres *= inv(f[k]);",
            "\tres %= c;",
            "\tres *= inv(f[n-k]);",
            "\tres %= c;",
            "\treturn res;",
            "}",
        ],
        "description": "Exponentiation, Inversion, Combination"
    },

    "Tree distances": {
        "prefix": "call_tree",
        "body": [
            "void dfs(int u, int c=-1) {",
            "\tin[u] = ++te;",
            "\tfor (int &i : g[u]) {",
            "\t\tif (i == c) continue;",
            "\t\tp[i] = u;",
            "\t\tlev[i] = lev[u] + 1;",
            "\t\tdfs(i, u);",
            "\t}",
            "\tout[u] = ++te;",
            "}",
            "",
            "bool is(int a, int b) {",
            "\tif (in[a] <= in[b] && out[a] >= out[b]) return 1;",
            "\telse return 0;",
            "}",
            "",
            "void build(int n) {",
            "\tfor (int i = 1; i <= n; i++) up[0][i] = p[i];",
            "\tfor (int i = 1; i < K; i++) {",
            "\t\tfor (int j = 1; j <= n; j++) {",
            "\t\t\tup[i][j] = up[i-1][up[i-1][j]];",
            "\t\t}",
            "\t}",
            "}",
            "",
            "int lca(int a, int b) {",
            "\tif (is(a, b)) return a;",
            "\tif (is(b, a)) return b;",
            "\tfor (int i = K-1; i >= 0; i--) {",
            "\t\tif (!is(up[i][a], b)) a = up[i][a];",
            "\t}",
            "\treturn up[0][a];",
            "}",
        ],
        "description": "DFS, Binary Lifting, LCA, SubTree"
    }
}
/*
    "": {
        "prefix": "",
        "body": [
            
        ],
        "description": ""
    },
*/
